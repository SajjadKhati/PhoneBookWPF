using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DataAccess.EntityModule.Class.Entity
{
    /// <summary>
    /// موجودیت آدرس<br/><br/>
    /// 
    /// این موجودیت ، رابطه ی چند به چند با موجودیت 
    /// <see cref="T:DataAccess.EntityModule.Class.Entity.PersonEntity" />
    /// دارد . هم هر رکورد از این موجودیت (آدرس) میتواند متعلق به چندین رکورد از موجودیت شخص باشد
    /// و هم اینکه هر رکورد از شخص ، میتواند چندین رکورد از موجودیت آدرس داشته باشد .<br/><br/>
    /// 
    /// چون حتی یک صفت یا پروپرتی در این موجودیت
    /// پیدا نمیشود که با حداکثر ، یک رکورد در موجودیت 
    /// <see cref="T:DataAccess.EntityModule.Class.Entity.PersonEntity" />
    /// ارتباط باشد ، بلکه ممکن است که با بیشتر از یک رکورد آنها در ارتباط باشد ،
    /// بنابراین نیازی به ایجاد جدول مشترکی که نیاز به تعریف آن صفت در آن جدول مشترک باشد ، نیست .<br/>
    /// پس نیازی نداریم که بصورت صریح ، آن جدول مشترک را تعریف کنیم چون آن جدول مشترک ، فقط شامل کلیدها هستند و شامل اطلاعات داده ای نیستند .<br/><br/>
    /// بنابراین همین قدر کافی هست که خودِ انتیتی فریم ورک ، برای مان بصورت ضمنی آن جدول مشترک را ایجاد کند .
    /// </summary>
    public class AddressEntity
    {
        /// <summary>
        /// شناسه ی موجودیت آدرس
        /// </summary>
        public int Id { get; set; }


        /// <summary>
        /// نام استان مربوط به شخص .<br/><br/>
        /// 
        /// این پروپرتی ، با موجودیت
        ///  <see cref="T:DataAccess.EntityModule.Class.Entity.ProvinceEntity" />
        /// اشتباه گرفته نشود . آن موجودیت ، برای ذخیره ی اطلاعات کل استان های کشور در این برنامه هست .
        /// </summary>
        public string Province{ get; set; }


        /// <summary>
        /// نام شهر مربوط به شخص .<br/><br/>
        /// 
        /// این پروپرتی ، با موجودیت
        ///  <see cref="T:DataAccess.EntityModule.Class.Entity.CityEntity" />
        /// اشتباه گرفته نشود . آن موجودیت ، برای ذخیره ی اطلاعات کل شهرهای مروط به هر استان کشور در این برنامه هست .
        /// </summary>
        public string City{ get; set; }


        /// <summary>
        /// آدرس مربوط به شخص ، بجز نام استان و شهر
        /// </summary>
        public string Address{ get; set; }


        /// <summary>
        /// کد پستی شخص<br/><br/>
        ///
        /// مقدار دادن به کد پستی (این پروپرتی) ، اختیاری هست . بخاطر اینکه این صفت در جدول دیتابیس ، بصورت nullable ذخیره شود ، بصورت نوع long? که قابلیت null دادن ، دارد ،
        /// در نظر میگیریم . چون استراکچرها ، قابلیت null پذیری ، ندارند .<br/><br/>
        /// 
        /// دقت شود که کد پستی ، فقط و حداکثر با یک رکورد از موجودیت 
        /// <see cref="T:DataAccess.EntityModule.Class.Entity.PersonEntity" />
        /// در تماس نیست . چون ممکن است که یک مقدار از صفت کد پستی در این موجودیت ، با بیشتر از یک رکورد از موجودیتِ 
        /// <see cref="T:DataAccess.EntityModule.Class.Entity.PersonEntity" />
        /// در ارتباط باشد . یعنی ممکن است که این کد پستی ، برای چند نفری که در یک خانواده و خانه زندگی میکنند ، باشد .<br/><br/>
        /// 
        /// به همین دلیل ، نیازی نیست که جدول مشترکِ صریح ای بخاطر ارتباط چند به چند بین این موجودیت و موجودیت 
        /// <see cref="T:DataAccess.EntityModule.Class.Entity.PersonEntity" />
        /// ساخته شود تا اینکه این صفتِ کد پستی ، به آن جدول مشترک ، منتقل شود .
        /// پس ، همین کافی است که خودِ انتیتی فریم ورک ، در این ارتباطِ چند به چند ، بصورت خودکار ، آن جدول مشترک را بصورت ضمنی بسازد .<br/><br/>
        /// 
        /// هر چند میتوانیم کد پستی را بصورت رشته ذخیره کنیم ، اما یکی از مزایای ذخیره بصورت عدد ، حجم کمتر آن است .
        /// </summary>
        public long? PostalCode{ get; set; }


        /// <summary>
        /// Navigation Collection Property برای موجودیت شخص <br/><br/>
        /// 
        /// این موجودیت ، رابطه ی "چند به چند" با موجودیتِ 
        /// <see cref="T:DataAccess.EntityModule.Class.Entity.PersonEntity" />
        /// دارد . اما از آنجا که صفت یا پروپرتی ای در هر کدام از این موجودیت ها وجود ندارد که مربوط به یک رکورد خاص از موجودیتِ طرف دیگر باشد ، یعنی ، حتی یک صفت در این موجودیت
        /// پیدا نمیشود که با حداکثر ، یک رکورد در موجودیت 
        /// <see cref="T:DataAccess.EntityModule.Class.Entity.PersonEntity" />
        /// مربوط باشد ، بلکه ممکن است که با بیشتر از یک رکورد آنها در ارتباط باشد ، 
        /// بنابراین نیازی به ایجاد جدول مشترکی که نیاز به تعریف آن صفت در آن جدول مشترک باشد ، نیست .<br/><br/>
        /// 
        /// صفت یا پروپرتی PostalCode هم چون ممکن است با چند رکورد از موجودیتِ 
        /// <see cref="T:DataAccess.EntityModule.Class.Entity.PersonEntity" />
        /// در ارتباط باشد ، پس باید در همین موجودیت تعریف شود . دلیل کاملش در توضیحات همان پروپرتی داده شد . پروپرتی های دیگر در این موجودیت مثل استان و شهر و حتی آدرس ،
        /// که قطعا ممکن هستند که با چند رکورد از موجودیت 
        /// <see cref="T:DataAccess.EntityModule.Class.Entity.PersonEntity" />
        /// در ارتباط باشند .<br/><br/>
        /// 
        /// پس نیازی نداریم که بصورت صریح ، آن جدول مشترک را تعریف کنیم چون آن جدول مشترک ، فقط شامل کلیدها هستند و شامل اطلاعات داده ای نیستند .
        /// بنابراین همین قدر کافی هست که خود EF ، برای مان بصورت ضمنی آن جدول مشترک را ایجاد کند .<br/><br/>
        /// 
        /// برای استفاده از lazy loading ، این عضو از Navigation Collection Property را بصورت virtual تعریف کردیم .
        /// </summary>
        public virtual ICollection<PersonEntity> Persons{ get; set; }
    }
}
